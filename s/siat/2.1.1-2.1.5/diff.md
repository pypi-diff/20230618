# Comparing `tmp/siat-2.1.1-py3-none-any.whl.zip` & `tmp/siat-2.1.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 1691023 bytes, number of entries: 120
+Zip file size: 1693057 bytes, number of entries: 120
 -rw-rw-rw-  2.0 fat      840 b- defN 23-Apr-10 11:29 siat/__init__.py
 -rw-rw-rw-  2.0 fat     2130 b- defN 23-Apr-10 11:29 siat/allin.py
 -rw-rw-rw-  2.0 fat      747 b- defN 23-Apr-10 11:29 siat/alpha_vantage_test.py
 -rw-rw-rw-  2.0 fat    28555 b- defN 23-Apr-10 11:29 siat/assets_liquidity.py
 -rw-rw-rw-  2.0 fat     1285 b- defN 23-Apr-10 11:29 siat/assets_liquidity_test.py
 -rw-rw-rw-  2.0 fat    10110 b- defN 23-Apr-10 11:29 siat/barrons_scraping_test.py
 -rw-rw-rw-  2.0 fat    36597 b- defN 23-Apr-10 11:29 siat/beta_adjustment.py
@@ -51,15 +51,15 @@
 -rw-rw-rw-  2.0 fat  2047492 b- defN 23-Jun-05 00:28 siat/fund_china.pickle
 -rw-rw-rw-  2.0 fat    74734 b- defN 23-Jun-10 07:59 siat/fund_china.py
 -rw-rw-rw-  2.0 fat     6649 b- defN 23-Apr-10 11:29 siat/fund_china_test.py
 -rw-rw-rw-  2.0 fat     1116 b- defN 23-Apr-10 11:29 siat/fund_test.py
 -rw-rw-rw-  2.0 fat    17513 b- defN 23-Jun-10 08:35 siat/future_china.py
 -rw-rw-rw-  2.0 fat     1163 b- defN 23-Apr-10 11:29 siat/future_china_test.py
 -rw-rw-rw-  2.0 fat     2402 b- defN 23-Apr-10 11:29 siat/global_index_test.py
--rw-rw-rw-  2.0 fat    63837 b- defN 23-Jun-10 02:57 siat/grafix.py
+-rw-rw-rw-  2.0 fat    64367 b- defN 23-Jun-18 17:17 siat/grafix.py
 -rw-rw-rw-  2.0 fat     3150 b- defN 23-Apr-10 11:29 siat/grafix_test.py
 -rw-rw-rw-  2.0 fat    30544 b- defN 23-Apr-10 11:29 siat/holding_risk.py
 -rw-rw-rw-  2.0 fat      474 b- defN 23-Apr-10 11:29 siat/holding_risk_test.py
 -rw-rw-rw-  2.0 fat     3936 b- defN 23-Apr-10 11:29 siat/local_debug_test.py
 -rw-rw-rw-  2.0 fat    31158 b- defN 23-Apr-10 11:29 siat/market_china.py
 -rw-rw-rw-  2.0 fat    95641 b- defN 23-Apr-10 13:16 siat/markowitz.py
 -rw-rw-rw-  2.0 fat     1593 b- defN 23-Apr-10 11:29 siat/markowitz_ccb_test.py
@@ -85,19 +85,19 @@
 -rw-rw-rw-  2.0 fat   101523 b- defN 23-May-27 06:22 siat/sector_china.py
 -rw-rw-rw-  2.0 fat     5843 b- defN 23-Apr-11 14:17 siat/sector_china_test.py
 -rw-rw-rw-  2.0 fat    29185 b- defN 23-May-25 02:36 siat/security_price.py
 -rw-rw-rw-  2.0 fat    72184 b- defN 23-Jun-07 15:20 siat/security_prices.py
 -rw-rw-rw-  2.0 fat    10779 b- defN 23-Apr-10 11:29 siat/security_prices_test.py
 -rw-rw-rw-  2.0 fat     1335 b- defN 23-Apr-10 11:29 siat/setup.py
 -rw-rw-rw-  2.0 fat     1418 b- defN 23-Apr-10 11:29 siat/shenwan index history test.py
--rw-rw-rw-  2.0 fat   118751 b- defN 23-Jun-14 03:39 siat/stock.py
+-rw-rw-rw-  2.0 fat   118820 b- defN 23-Jun-18 16:38 siat/stock.py
 -rw-rw-rw-  2.0 fat    31655 b- defN 23-Apr-10 11:29 siat/stock_advice_linear.py
 -rw-rw-rw-  2.0 fat     1312 b- defN 23-Apr-10 11:29 siat/stock_base.py
--rw-rw-rw-  2.0 fat    76007 b- defN 23-Jun-11 16:27 siat/stock_china.py
--rw-rw-rw-  2.0 fat     1276 b- defN 23-Apr-10 11:29 siat/stock_china_test.py
+-rw-rw-rw-  2.0 fat    82785 b- defN 23-Jun-17 02:52 siat/stock_china.py
+-rw-rw-rw-  2.0 fat     1294 b- defN 23-Jun-14 07:32 siat/stock_china_test.py
 -rw-rw-rw-  2.0 fat  1266744 b- defN 23-Jun-05 00:13 siat/stock_info.pickle
 -rw-rw-rw-  2.0 fat     6122 b- defN 23-Apr-10 11:29 siat/stock_info_test.py
 -rw-rw-rw-  2.0 fat     1014 b- defN 23-Apr-10 11:29 siat/stock_list_china_test.py
 -rw-rw-rw-  2.0 fat    36738 b- defN 23-Apr-10 11:29 siat/stock_prices_kneighbors.py
 -rw-rw-rw-  2.0 fat    13991 b- defN 23-Apr-10 11:29 siat/stock_prices_linear.py
 -rw-rw-rw-  2.0 fat    25017 b- defN 23-Apr-10 11:29 siat/stock_profile.py
 -rw-rw-rw-  2.0 fat    72626 b- defN 23-Apr-10 11:29 siat/stock_technical.py
@@ -106,17 +106,17 @@
 -rw-rw-rw-  2.0 fat    16648 b- defN 23-Apr-18 09:06 siat/test2_graphviz.py
 -rw-rw-rw-  2.0 fat    16999 b- defN 23-Apr-14 14:38 siat/test_graphviz.py
 -rw-rw-rw-  2.0 fat    14492 b- defN 23-Apr-10 11:29 siat/transaction.py
 -rw-rw-rw-  2.0 fat    18580 b- defN 23-Apr-10 11:29 siat/transaction_test.py
 -rw-rw-rw-  2.0 fat   117953 b- defN 23-Apr-10 11:29 siat/translate-20230125.py
 -rw-rw-rw-  2.0 fat   118133 b- defN 23-Apr-10 11:29 siat/translate-20230206.py
 -rw-rw-rw-  2.0 fat   121657 b- defN 23-Apr-10 11:29 siat/translate-20230215.py
--rw-rw-rw-  2.0 fat   133928 b- defN 23-Jun-10 03:45 siat/translate.py
+-rw-rw-rw-  2.0 fat   133928 b- defN 23-Jun-18 17:34 siat/translate.py
 -rw-rw-rw-  2.0 fat     3936 b- defN 23-Apr-10 11:29 siat/universal_test.py
 -rw-rw-rw-  2.0 fat    51342 b- defN 23-May-11 00:30 siat/valuation_china.py
 -rw-rw-rw-  2.0 fat     1571 b- defN 23-Apr-10 11:29 siat/valuation_market_china_test.py
 -rw-rw-rw-  2.0 fat    14859 b- defN 23-Apr-10 11:29 siat/var_model_validation.py
--rw-rw-rw-  2.0 fat     1410 b- defN 23-Jun-14 03:41 siat-2.1.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-14 03:41 siat-2.1.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        5 b- defN 23-Jun-14 03:41 siat-2.1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     9602 b- defN 23-Jun-14 03:41 siat-2.1.1.dist-info/RECORD
-120 files, 7729848 bytes uncompressed, 1676383 bytes compressed:  78.3%
+-rw-rw-rw-  2.0 fat     1410 b- defN 23-Jun-18 17:40 siat-2.1.5.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-18 17:40 siat-2.1.5.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        5 b- defN 23-Jun-18 17:40 siat-2.1.5.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     9602 b- defN 23-Jun-18 17:40 siat-2.1.5.dist-info/RECORD
+120 files, 7737243 bytes uncompressed, 1678417 bytes compressed:  78.3%
```

## zipnote {}

```diff
@@ -342,20 +342,20 @@
 
 Filename: siat/valuation_market_china_test.py
 Comment: 
 
 Filename: siat/var_model_validation.py
 Comment: 
 
-Filename: siat-2.1.1.dist-info/METADATA
+Filename: siat-2.1.5.dist-info/METADATA
 Comment: 
 
-Filename: siat-2.1.1.dist-info/WHEEL
+Filename: siat-2.1.5.dist-info/WHEEL
 Comment: 
 
-Filename: siat-2.1.1.dist-info/top_level.txt
+Filename: siat-2.1.5.dist-info/top_level.txt
 Comment: 
 
-Filename: siat-2.1.1.dist-info/RECORD
+Filename: siat-2.1.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## siat/grafix.py

```diff
@@ -907,15 +907,15 @@
     plt.title(titletxt,fontweight='bold',fontsize=title_txt_size)
     plt.show()
     
     return
 
 #==============================================================================
 def draw_lines(df0,y_label,x_label,axhline_value,axhline_label,title_txt, \
-               data_label=True,resample_freq='H',smooth=True,linewidth=1.5,loc='best'):
+               data_label=True,resample_freq='H',smooth=True,linewidth=1.5,loc='best',annotate=False):
     """
     函数功能：根据df的内容绘制折线图
     输入参数：
     df：数据框。有几个字段就绘制几条折现。必须索引，索引值将作为X轴标记点
     要求：df的索引为pandas的datetime日期型
     axhline_label: 水平辅助线标记。如果为空值则不绘制水平辅助线
     axhline_value: 水平辅助线的y轴位置
@@ -970,15 +970,25 @@
             print("  #Error(draw_lines): null dataframe for graphics in column",c)
             continue
         if len(dfg)==0:
             print("  #Error(draw_lines): no data for graphics in column",c)
             continue
         
         #plt.plot(dfg,label=c,linewidth=linewidth,ls=lsc,marker=mkc,markersize=3)
-        plt.plot(dfg,label=codetranslate(c),linewidth=linewidth,ls=lsc,marker=mkc,markersize=3)
+        if not annotate:
+            plt.plot(dfg,label=codetranslate(c),linewidth=linewidth,ls=lsc,marker=mkc,markersize=3)
+        else:
+            plt.plot(dfg[c],label=codetranslate(c),linewidth=linewidth,ls=lsc,marker=mkc,markersize=3)
+            df_end=dfg.tail(1)
+            y_end = round(df_end[c].min(),2)    # 末端的y坐标
+            x_end = df_end[c].idxmin() # 末端值的x坐标 
+            plt.annotate(text=codetranslate(c)+':'+str(y_end), 
+                                 xy=(x_end, y_end),
+                                 xytext=(x_end, y_end),fontsize=9)   
+            
         #plt.plot(df[c],label=c,linewidth=1.5,marker=mkc,markersize=3)
         #为折线加数据标签
         if data_label==True:
             for a,b in zip(df.index,df[c]):
                 plt.text(a,b+0.02,str(round(b,2)), \
                          ha='center',va='bottom',fontsize=7)
```

## siat/stock.py

```diff
@@ -1233,15 +1233,16 @@
     linewidth=1.5
     scaling_option='start'
     
 def compare_msecurity(tickers,measure,start,end, \
                       axhline_value=0,axhline_label='', \
                       preprocess='none',linewidth=1.5, \
                       scaling_option='start', \
-                      graph=True,loc='best'):
+                      graph=True,loc='best', \
+                      annotate=False):
     """
     功能：比较并绘制多条证券指标曲线（多于2条），个数可为双数或单数
     注意：
     tickers中须含有2个及以上股票代码，
     measure为单一指标，
     axhline_label不为空时绘制水平线
     
@@ -1492,17 +1493,18 @@
     dfs2.fillna(axis=0,method='bfill',inplace=True)
 
     if 'Ret%' in measure:
         if axhline_label=='':
             axhline_label='收益零线'
 
     draw_lines(dfs2,y_label,x_label,axhline_value,axhline_label,title_txt, \
-               data_label=False,resample_freq='H',smooth=True,linewidth=linewidth,loc=loc)
+               data_label=False,resample_freq='H',smooth=True,linewidth=linewidth,loc=loc, \
+               annotate=annotate)
 
-    return dfs
+    return dfs2
 
 if __name__ =="__main__":
     tickers=['000001.SS',"^HSI","^TWII"]
     df=compare_msecurity(tickers,'Close','2020-1-1','2022-12-14',preprocess='standardize')
     df=compare_msecurity(tickers,'Close','2020-1-1','2022-12-14',preprocess='normalize')
     df=compare_msecurity(tickers,'Close','2020-1-1','2022-12-14',preprocess='logarithm')
     df=compare_msecurity(tickers,'Close','2020-1-1','2022-12-14',preprocess='scaling')
@@ -1851,15 +1853,15 @@
     fig.autofmt_xdate()
 
     if lang == 'English':   
         titletxt=texttranslate("Security Price Candlestick Demo: ")+codetranslate(str(stkcd))
         price_txt='Price'
         source_txt="Source: "
     else:
-        titletxt=texttranslate("证券价格走势蜡烛图演示：")+codetranslate(str(stkcd))
+        titletxt=texttranslate("K线图/蜡烛图演示：")+codetranslate(str(stkcd))
         price_txt='价格'
         source_txt="数据来源: "
 
     plt.title(titletxt,fontsize=title_txt_size,fontweight='bold')
     plt.ylabel(price_txt,fontsize=ylabel_txt_size)
     plt.xticks(rotation=30)        
     plt.legend(loc="best",fontsize=legend_txt_size)
```

## siat/stock_china.py

```diff
@@ -16,100 +16,145 @@
 from siat.security_prices import *
 
 #==============================================================================
 # 获得个股近一百个交易日的资金净流入数据
 #==============================================================================
 
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.Ss'
 
-def get_money_flowin(ticker):
+    dfp=get_money_flowin(ticker)
+    
+    end='2023-6-15'
+    dfp=get_money_flowin(ticker,end)
+
+def get_money_flowin(ticker,end='latest'):
     """
     功能：抓取个股近一百个交易日的资金净流入情况，以及大盘指数的情况
-    ticker：个股代码，不带后缀
+    ticker：个股代码，带后缀
     标准化方法：原始数据
+    注意：目前仅支持沪深股市
     """
+    ticker1=ticker.upper()[:6]
+    exch=ticker.upper()[7:9]
+    
     import akshare as ak
     import pandas as pd
     
     #判断沪深市场
-    l1=ticker[0]; market='sh'
-    if l1 in ['0','2','3']: market='sz'
-    #深市股票以0/2/3开头，沪市以6/9开头
-
+    if exch=='':
+        l1=ticker[0]; market='sh'
+        if l1 in ['0','2','3']: market='sz'
+        #深市股票以0/2/3开头，沪市以6/9开头
+    else:
+        if exch=='SS':
+            market='sh'
+        elif exch=='SZ':
+            market='sz'
+        else:
+            print("  #Warning(get_money_flowin): currently only support Shanghai/Shenzhen stock exchanges")
+            return None
+    
     #获得个股资金流动明细
     try:
-        df = ak.stock_individual_fund_flow(stock=ticker, market=market)
+        df = ak.stock_individual_fund_flow(stock=ticker1, market=market)
     except:
-        print("#Error(predict_price_direction): stock code not found for",ticker)
-        return
+        print("  #Error(get_money_flowin): money flow info unavailable for",ticker)
+        return None
 
     df['ticker']=ticker
+
+    df['Date']=df['日期'].apply(lambda x: pd.to_datetime(x))  #不带时区的日期
+    df.set_index('Date',inplace=True)
     df['date']=df['日期']
+    
+    df['Close']=df['收盘价'].apply(lambda x: float(x))
+    df['Change%']=df['涨跌幅'].apply(lambda x: float(x))
+    
     #类型转换
     df['netFlowInAmount_main']=df['主力净流入-净额'].apply(lambda x: float(x))
     df['netFlowInAmount_small']=df['小单净流入-净额'].apply(lambda x: float(x))
     df['netFlowInAmount_mid']=df['中单净流入-净额'].apply(lambda x: float(x))
     df['netFlowInAmount_big']=df['大单净流入-净额'].apply(lambda x: float(x))
     df['netFlowInAmount_super']=df['超大单净流入-净额'].apply(lambda x: float(x))
+    
+    # 总净流入金额：可正可负
     df['netFlowInAmount']=df['netFlowInAmount_main']+df['netFlowInAmount_small']+ \
-        df['netFlowInAmount_mid']+df['netFlowInAmount_big']+df['netFlowInAmount_super']
+                          df['netFlowInAmount_mid']+df['netFlowInAmount_big']+ \
+                          df['netFlowInAmount_super']
 
     df['netFlowInRatio%_main']=df['主力净流入-净占比'].apply(lambda x: float(x))
     df['netFlowInRatio%_small']=df['小单净流入-净占比'].apply(lambda x: float(x))
     df['netFlowInRatio%_mid']=df['中单净流入-净占比'].apply(lambda x: float(x))
     df['netFlowInRatio%_big']=df['大单净流入-净占比'].apply(lambda x: float(x))
     df['netFlowInRatio%_super']=df['超大单净流入-净占比'].apply(lambda x: float(x))
-    
-    #重要：删除有缺失值的记录，确保未收盘时能预测当天的收盘价涨跌方向
-    df.dropna(inplace=True)
 
-    df['Close']=df['收盘价'].apply(lambda x: float(x))
-    df['Change%']=df['涨跌幅'].apply(lambda x: float(x))
-
-    df['Date']=df['日期'].apply(lambda x: pd.to_datetime(x))  #不带时区的日期
-    df.set_index('Date',inplace=True)
+    #重要：处理有缺失值的记录，确保未收盘时能预测当天的收盘价涨跌方向
+    #df.dropna(inplace=True)
+    df.fillna(0,inplace=True)
+    
+    # 对数量级巨大的金额项进行对数处理，避免其对数量级小的项形成数量级压制
+    amtColList=['netFlowInAmount_main','netFlowInAmount_small','netFlowInAmount_mid', \
+                'netFlowInAmount_big','netFlowInAmount_super','netFlowInAmount']
+    import math
+    for a in amtColList:
+        # 取对数
+        df[a+'_ln']=df[a].apply(lambda x: math.log(x) if x>0 else -math.log(-x) if x<0 else 0)
+    
+    # 删除原有金额项目
+    df.drop(amtColList,axis=1,inplace=True)
     
     #去掉不用的字段
     dfdroplist=['主力净流入-净额','小单净流入-净额','中单净流入-净额','大单净流入-净额', \
                 '超大单净流入-净额','主力净流入-净占比','小单净流入-净占比', \
                 '中单净流入-净占比','大单净流入-净占比','超大单净流入-净占比', \
                 '收盘价','涨跌幅','日期']
     df.drop(labels=dfdroplist,axis=1,inplace=True)
     
-    #获得大盘指数
-    dpindex="sh000001"  #上证综合指数
-    if market == 'sz': dpindex="sz399001"   #深圳成分指数
-    dp=ak.stock_zh_index_daily(symbol=dpindex)
-    dp['Date']=dp.index
-    dp['Date']=dp['Date'].apply(lambda x: x.replace(tzinfo=None))   #去掉时区信息
-    dp.set_index('Date',inplace=True)
-    
-    #去掉不用的字段
-    dpdroplist=['open','high','low']
-    dp.drop(labels=dpdroplist,axis=1,inplace=True)
-    dp.rename(columns={'close':'dpClose','volume':'dpVolume'}, inplace = True)
-    
-    #合并大盘指数：索引日期均不带时区，否则出错
-    dfp=pd.merge(df,dp,how='left',left_index=True,right_index=True)  
-    
-    """
-    #取得标签/特征向量
-    ydf=dfp[['Close','Change%']]
-    X=dfp.drop(labels=['date','Close','Change%'],axis=1)
+    df.sort_index(ascending=True,inplace=True)
+    fromdate=df['date'].values[0]
+    todate=df['date'].values[-1]
+    
+    #获得大盘指数和交易量
+    dpindex="000001.SS"  #上证综合指数
+    if market == 'sz': dpindex="399001.SZ"   #深圳成分指数
+    df_dp_tmp=get_price(dpindex,fromdate,todate)
+    
+    df_dp_tmp['Volume_mkt']=df_dp_tmp['Volume'].apply(lambda x: math.log(x))
+    df_dp_tmp['Close_mkt']=df_dp_tmp['Close']
+    df_dp=df_dp_tmp[['Volume_mkt','Close_mkt']]
+    
+    # 获得股票交易量
+    df_stk_tmp=get_price(ticker,fromdate,todate)
+    df_stk_tmp['Volume_ln']=df_stk_tmp['Volume'].apply(lambda x: math.log(x))
+    df_stk=df_stk_tmp[['Open','High','Low','Adj Close','Volume_ln']]
+
+    # 合并
+    df_stk_mkt=pd.merge(df_stk,df_dp,how='left',left_index=True,right_index=True) 
+    
+    dfp_tmp=pd.merge(df,df_stk_mkt,how='left',left_index=True,right_index=True)
+    newColList=['date','Close','Change%','Adj Close','Open','High','Low','Volume_ln', \
+                'netFlowInRatio%_main','netFlowInRatio%_small','netFlowInRatio%_mid', \
+                'netFlowInRatio%_big','netFlowInRatio%_super', \
+                'netFlowInAmount_main_ln','netFlowInAmount_small_ln','netFlowInAmount_mid_ln', \
+                'netFlowInAmount_big_ln','netFlowInAmount_super_ln', 'netFlowInAmount_ln', \
+                'Close_mkt','Volume_mkt']
+    dfp=dfp_tmp[newColList]
     
-    scaler_X=preproc(X,preproctype=preproctype)
-    scaler_dfp=pd.merge(scaler_X,ydf,how='left',left_index=True,right_index=True) 
-    return scaler_dfp
-    """
+    if end=='latest':
+        dfp2=dfp
+    else:
+        jieguo,end2=check_date2(end)
+        if not jieguo:
+            dfp2=dfp
+        else:
+            dfp2=dfp[dfp['date'] <= end2]
     
-    return dfp
+    return dfp2
 
-if __name__=='__main__':
-    dfp=get_money_flowin('600519')
 
 #==============================================================================
 # 对特征数据进行预处理
 #==============================================================================
 
 def preprocess(X,preproctype='nop'):
     """
@@ -165,77 +210,94 @@
     scaler_X=preproc(X,preproctype='0-1')
 
 #==============================================================================
 # 构造适合机器学习的样本
 #==============================================================================
 if __name__=='__main__':
     ndays=1
-    preCumTimes=1
+    preCumTimes=5
+    
+    dfp=get_money_flowin('600519.SS')
+    
+    X,ydf,X_new=make_sample(dfp,ndays=1)
 
-def make_sample(dfp,ndays=1,preCumTimes=1):
+def make_sample(dfp,ndays=1,preCumTimes=5):
     """
     功能：构造适合机器学习的样本
     ndays：预测未来几个交易日
     preCumTimes：使用过去几倍交易日的累计数据，
     使用过去交易日的实际天数=preCumTimes * ndays
     preproctype：对特征数据进行预处理的类型
     """    
     
     preDays=ndays * preCumTimes
     
     #构造过去一段时间资金净流入累加值
-    dfp['netFlowInAmtCum_main']=dfp['netFlowInAmount_main'].rolling(window=preDays,min_periods=1).sum()
-    dfp['netFlowInAmtCum_small']=dfp['netFlowInAmount_small'].rolling(window=preDays,min_periods=1).sum()
-    dfp['netFlowInAmtCum_mid']=dfp['netFlowInAmount_mid'].rolling(window=preDays,min_periods=1).sum()
-    dfp['netFlowInAmtCum_big']=dfp['netFlowInAmount_big'].rolling(window=preDays,min_periods=1).sum()
-    dfp['netFlowInAmtCum_super']=dfp['netFlowInAmount_super'].rolling(window=preDays,min_periods=1).sum()
-    dfp['netFlowInAmtCum']=dfp['netFlowInAmount'].rolling(window=preDays,min_periods=1).sum()
+    amtColList=[]
+    colList=list(dfp)
+    for c in colList:
+        if 'Amount' in c:
+            amtColList=amtColList+[c]
+    
+    for c in amtColList:
+        dfp[c+'_cum']=dfp[c].rolling(window=preDays,min_periods=1).sum()
     
     #构造过去一段时间资金净流入比例均值
-    dfp['netFlowInRatioAvg%_main']=dfp['netFlowInRatio%_main'].rolling(window=preDays,min_periods=1).mean()    
-    dfp['netFlowInRatioAvg%_small']=dfp['netFlowInRatio%_small'].rolling(window=preDays,min_periods=1).mean() 
-    dfp['netFlowInRatioAvg%_mid']=dfp['netFlowInRatio%_mid'].rolling(window=preDays,min_periods=1).mean() 
-    dfp['netFlowInRatioAvg%_big']=dfp['netFlowInRatio%_big'].rolling(window=preDays,min_periods=1).mean() 
-    dfp['netFlowInRatioAvg%_super']=dfp['netFlowInRatio%_super'].rolling(window=preDays,min_periods=1).mean() 
-
+    ratioColList=[]
+    for c in colList:
+        if 'Ratio' in c:
+            ratioColList=ratioColList+[c]
+    
+    for c in ratioColList:
+        dfp[c+'_avg']=dfp[c].rolling(window=preDays,min_periods=1).mean()
+    
     #构造过去一段时间大盘指数的均值和标准差
-    dfp['dpCloseAvg']=dfp['dpClose'].rolling(window=preDays,min_periods=1).mean()
-    #dfp['dpCloseStd']=dfp['dpClose'].rolling(window=preDays,min_periods=1).std()
-    dfp['dpVolumeAvg']=dfp['dpVolume'].rolling(window=preDays,min_periods=1).mean()
-    #dfp['dpVolumeStd']=dfp['dpVolume'].rolling(window=preDays,min_periods=1).std()   
+    mktColList=['Close_mkt','Volume_mkt']
+    for c in mktColList:
+        dfp[c+'_avg']=dfp[c].rolling(window=preDays,min_periods=1).mean()
+        dfp[c+'_std']=dfp[c].rolling(window=preDays,min_periods=1).std()
     
     #重要：去掉前几行，此处位置敏感
-    dfp.dropna(inplace=True)
-    
-    #添加未来更多天的股价信息
-    ylist=[]
-    for nd in list(range(1,ndays+1)):
-        dfp['Close_next'+str(nd)]=dfp['Close'].shift(-nd)
-        ylist=ylist+['Close_next'+str(nd)]
-        dfp['Change%_next'+str(nd)]=dfp['Change%'].shift(-nd)
-        ylist=ylist+['Change%_next'+str(nd)]
-    
-    X = dfp[[
-         'netFlowInAmount_main','netFlowInAmount_small','netFlowInAmount_mid', \
-         'netFlowInAmount_big','netFlowInAmount_super','netFlowInAmount', \
-         
-         'netFlowInAmtCum_main','netFlowInAmtCum_small','netFlowInAmtCum_mid', \
-         'netFlowInAmtCum_big','netFlowInAmtCum_super','netFlowInAmtCum', \
-         
-         'netFlowInRatio%_main','netFlowInRatio%_small','netFlowInRatio%_mid', \
-         'netFlowInRatio%_big','netFlowInRatio%_super',
-         
-         'netFlowInRatioAvg%_main','netFlowInRatioAvg%_small','netFlowInRatioAvg%_mid', \
-         'netFlowInRatioAvg%_big','netFlowInRatioAvg%_super',
-         
-         'dpClose','dpCloseAvg','dpVolume','dpVolumeAvg']]
+    dfp1=dfp.dropna()
+    if len(dfp1)==0:
+        print("  #Error(make_sample): dropna caused empty dataframe, process stopped")
+        return None,None
+    
+    #按照ndays滚动
+    newColList=list(dfp1)
+    newColList.remove('date')
+    dfp2=dfp1[newColList]
+    for c in newColList:
+        dfp2[c+'_roll']=dfp2[c].rolling(window=ndays,min_periods=1).mean()
+    
+    newColList2=list(dfp2)
+    newColList3=[]
+    for c in newColList2:
+        if '_roll' in c:
+            newColList3=newColList3+[c]
+    newColList3=newColList3+['Close','Change%']
+    dfp3=dfp2[newColList3]
+    
+    #添加未来一个单位(ndays)的股价信息
+    dfp3['Close_next']=dfp3['Close'].shift(-1)
+    dfp3['Change%_next']=dfp3['Change%'].shift(-1)
+    ylist=['Close_next','Change%_next']
+
+    #供训练用的数据集
+    XCollist=list(dfp3)
+    for c in ylist:
+        XCollist.remove(c)
+    dfp4=dfp3.dropna()
+    X = dfp4[XCollist]
+    ydf = dfp4[ylist]    
     
-    ydf = dfp[ylist]
+    # X_new
+    X_new = dfp3.tail(1)[XCollist]
     
-    return X,ydf
+    return X,ydf,X_new
 
 #==============================================================================
 # 训练模型，获得最优模型参数，进行预测
 #==============================================================================
 if __name__=='__main__':
     noday=1
     y='Close'   
@@ -250,14 +312,16 @@
     diff=0.03,min_score=0.6,votes=100,max_neighbours=10,max_RS=10,printout=True):
     """
     功能：训练模型，选择最优参数，预测
     X：特征矩阵
     ydf：标签矩阵
     nodays：预测未来第几天
     y：标签，默认'Close'为股价，'Change%'为涨跌幅，'Direction'为涨跌方向
+    
+    未用！
     """
     ylist=['Close','Change%','Direction']
     if not (y in ylist):
         print("  #Error(train_predict_knn):",y,"not within",ylist)
     clflist=['Direction']
     reglist=['Close','Change%']
     
@@ -328,14 +392,16 @@
     r1=r0.sort_values(by=['spread','test_score'],ascending=[True,False])        
     #优先查看测试分数最高的结果
     r2=r0.sort_values(by=['test_score','spread'],ascending=[False,True])
 
     if votes > len(r2): votes=len(r2)
     r2head=r2.head(votes)    
     
+    # 未完
+    
 #==============================================================================
 # 训练，获得最优模型参数
 #==============================================================================
 if __name__=='__main__':
     ndays=1
     max_neighbors=10
     max_p=6
@@ -343,14 +409,16 @@
     rs=0
 
 def training_knn_clf(scaler_X,ydf,ndays=1,max_neighbors=10,max_p=6,cv=5,rs=0):
     '''
     功能：对(X,y)
     scaler_X: 特征矩阵
     y：标签矩阵
+    
+    未用！
     '''
     
     #获得分类变量y
     ydf['nextChange%']=ydf['Change%'].shift(-ndays)
     ydf['nextDirection']=ydf['nextChange%'].apply(lambda x: 'Higher' if x>0 else 'Lower')
     y=ydf['nextDirection']
     
@@ -393,79 +461,69 @@
     return best_params,train_score,test_score
 
     
 #==============================================================================
 # Forecasting stock price directions by money flow in/out, using knn
 #==============================================================================
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.SS'
+    ticker='000723.SZ'
+    
     ndays=1
-    market='sh'
-    diff=0.03
+    min_score=0.9
+    diff=0.01
     votes=100
     max_neighbours=10
     max_RS=10
+    printout=True
+    
+    df=get_money_flowin(ticker,end='2023-6-15')
+    decision,known_close,known_day=price_direction_knn(ticker,df,ndays=1)
 
-def price_direction_knn(ticker,df,ndays=1,diff=0.03,min_score=0.6,votes=100,max_neighbours=10,max_RS=10,printout=True):
+def price_direction_knn(ticker,df,ndays=1,diff=0.01,min_score=0.9,votes=100,max_neighbours=10,max_RS=10,printout=True):
 
     """
     功能：基于个股资金流动预测次日股票涨跌方向，涨或跌
     ticker：股票代码，无后缀
     df：个股资金净流入
-    dp：大盘信息
     ndays：预测几天后的股价涨跌方向，默认1天
-    market：sh-沪市，sz-深市
-    diff：泛化精度，越小越好，默认0.03
-    votes：软表决票数，默认100
+    diff：泛化精度，越小越好
+    min_score：最小测试分数
+    votes：软表决票数
     max_neighbours：最大邻居个数
     max_RS：最大随机数种子
     """
     import pandas as pd
     
-    #构造标签
-    df['nextClose']=df['Close'].shift(-ndays)
-    df['nextChange%']=df['Change%'].shift(-ndays)
-    df['nextDirection']=df['nextChange%'].apply(lambda x: 1 if float(x) > 0 else -1)
-    
-    #构造特征
-    df['netFlowInChg_main']=df['netFlowInAmount_main'] - df['netFlowInAmount_main'].shift(-ndays)
-    df['netFlowInChg_small']=df['netFlowInAmount_small'] - df['netFlowInAmount_small'].shift(-ndays)
-    df['netFlowInChg_mid']=df['netFlowInAmount_mid'] - df['netFlowInAmount_mid'].shift(-ndays)
-    df['netFlowInChg_big']=df['netFlowInAmount_big'] - df['netFlowInAmount_big'].shift(-ndays)
-    df['netFlowInChg_super']=df['netFlowInAmount_super'] - df['netFlowInAmount_super'].shift(-ndays)
-    df['netFlowInChg']=df['netFlowInAmount'] - df['netFlowInAmount'].shift(-ndays)
-    
-    df['netFlowInRatio%Chg_main']=df['netFlowInRatio%_main'] - df['netFlowInRatio%_main'].shift(-ndays)
-    df['netFlowInRatio%Chg_small']=df['netFlowInRatio%_small'] - df['netFlowInRatio%_small'].shift(-ndays)
-    df['netFlowInRatio%Chg_mid']=df['netFlowInRatio%_mid'] - df['netFlowInRatio%_mid'].shift(-ndays)
-    df['netFlowInRatio%Chg_big']=df['netFlowInRatio%_big'] - df['netFlowInRatio%_big'].shift(-ndays)
-    df['netFlowInRatio%Chg_super']=df['netFlowInRatio%_super'] - df['netFlowInRatio%_super'].shift(-ndays)
-
-    df['dpCloseChg']=df['dpClose'] - df['dpClose'].shift(-ndays)
-    df['dpVolumeChg']=df['dpVolume'] - df['dpVolume'].shift(-ndays)
-
-    df2=df[['date','netFlowInChg_main',
-       'netFlowInChg_small','netFlowInChg_mid','netFlowInChg_big', \
-       'netFlowInChg_super','netFlowInChg','netFlowInRatio%Chg_main','netFlowInRatio%Chg_small', \
-       'netFlowInRatio%Chg_mid','netFlowInRatio%Chg_big','netFlowInRatio%Chg_super', \
-       'Close','Change%','dpCloseChg','dpVolumeChg','nextClose','nextChange%','nextDirection']]
-
-    #记录最新指标，用于预测次日涨跌
-    x_last=df2.copy().tail(1)
-    today=x_last['date'].values[0]
-    today_close=x_last['Close'].values[0]
-    x_last.drop(labels=['date','nextClose', 'nextChange%', 'nextDirection'],axis=1,inplace=True)
-    X_new = x_last.head(1).values
-
-    #建立样本：特征序列
-    df2.dropna(inplace=True)
-    X=df2.drop(labels=['date','nextClose', 'nextChange%', 'nextDirection'],axis=1)
-
+    # 判断是否周末无交易免预测
+    known_day=df.tail(1)['date'].values[0]
+    
+    tdate=date_adjust(known_day, adjust=ndays)
+    tdate_pd=pd.to_datetime(tdate)
+    tdate_wd=tdate_pd.weekday()
+    if tdate_wd in [5,6]:
+        print("  #Warning: after",ndays,"day(s) is",tdate,"(weekend), no trading")
+        decision='~'
+        known_close=df.tail(1)['Close'].values[0]
+        
+        return decision,known_close,known_day
+    
+    #构造样本：标签ydf，特征矩阵X，预测X_new
+    X,ydf,X_new=make_sample(df,ndays=ndays)
+    
+    #X_new1=X_new.head(1).values
+    known_day_np=X_new.index.values[0]
+    known_day_pd=pd.to_datetime(known_day_np)    
+    known_day=known_day_pd.strftime("%Y-%m-%d")
+    known_close=X_new['Close'].values[0]
+    
+    ydf['nextDirection']=ydf['Change%_next'].apply(lambda x: 1 if x>0 else -1 if x <0 else 0)
+    
     #建立样本：标签序列
-    y1=df2['nextDirection'] #二分类
+    y1=ydf['nextDirection'] #二分类
     #y2=df2['nextChange%']   #回归
     #y3=df2['nextClose']     #回归
 
     #拆分训练集和测试集：y1
     from sklearn.model_selection import train_test_split
     #引入k近邻分类模型：
     from sklearn.neighbors import KNeighborsClassifier
@@ -476,190 +534,273 @@
     wlist=['uniform','distance']
     mlist1=['braycurtis','canberra','correlation','dice','hamming','jaccard']
     mlist2=['kulsinski','matching','rogerstanimoto','russellrao']
     mlist3=['sokalmichener','sokalsneath','sqeuclidean','yule','chebyshev']
     mlist4=['cityblock','euclidean','minkowski','cosine']
     mlist=mlist1+mlist2+mlist3+mlist4
     rslist=list(range(0,max_RS+1))
+    
     results=pd.DataFrame(columns=('spread','train_score','test_score', \
                                   'neighbours','weight','metric','random','pred'))
     print('\nSearching for best parameters of knn model in',ndays,'trading days ...')
-    print('  Progress: 0%, ',end='')
+    print('  Progress: 0% ',end='')
     for n in nlist:
         for w in wlist:
             for m in mlist:
                 for rs in rslist:    
                     knn1=KNeighborsClassifier(n_neighbors=n,weights=w,metric=m,n_jobs=-1)
                     X_train,X_test,y_train,y_test=train_test_split(X,y1,random_state=rs)
-                    knn1.fit(X_train, y_train)
+                    tmp=knn1.fit(X_train, y_train) #调试时去掉tmp=可跟踪模型参数
                     train_score=round(knn1.score(X_train, y_train),3)
                     test_score=round(knn1.score(X_test, y_test),3)
                     prediction=knn1.predict(X_new)[0]
                     spread=abs(round(train_score-test_score,3))
                     
                     row=pd.Series({'spread':spread,'train_score':train_score, \
                                    'test_score':test_score,'neighbours':n, \
                                    'weight':w,'metric':m,'random':rs,'pred':prediction})
                     results=results.append(row,ignore_index=True)
-        print(int(n/n_num*100),'\b%, ',end='')
+        print(int(n/n_num*100),'\b% ',end='')
     print('done.') 
     
-    #去掉严重过拟合的结果           
-    r0=results[results['train_score'] < 1]
-    #去掉训练集、测试集分数不过半的模型    
-    r0=r0[r0['train_score'] > min_score]
-    r0=r0[r0['test_score'] > min_score]
+    
+    # 过滤训练/测试分数差的结果
+    r0=results[(results['train_score']>=min_score) & (results['test_score']>=min_score)]
+    # 避免min_score设置得太高导致无结果，或者数量太多
+    r0_len=len(r0)
+    #if r0_len==0 or r0_len > votes:
+    if r0_len==0:
+        train_score_max=results['train_score'].max()
+        test_score_max=results['test_score'].max()
+        min_score_new=min(train_score_max,test_score_max)
+        r0=results[(results['train_score']>=min_score_new) & (results['test_score']>=min_score_new)]
+        
+        if len(r0)==0:
+            spread_quantile=results['spread'].quantile(q=0.01)
+            r0_spread=results[(results['spread']<spread_quantile)]
+            if len(r0_spread)==0:
+                r0_spread=results[(results['spread']<=spread_quantile)]
+
+            test_score_quantile=r0_spread['test_score'].quantile(q=0.99)
+            r0=r0_spread[(r0_spread['test_score']>test_score_quantile)]
+            if len(r0)==0:
+                r0=r0_spread[(r0_spread['test_score']>=test_score_quantile)]
+                
+            train_score_max=r0['train_score'].max()
+            test_score_max=r0['test_score'].max()
+            min_score_new=min(train_score_max,test_score_max)
+            
+        print("  #Warning: filtering parameter min_score has been adjusted to",min_score_new)
+    
     #去掉泛化效果差的结果
-    r0=r0[r0['spread'] < diff]  #限定泛化差距
-    #优先查看泛化效果最优的结果
-    r1=r0.sort_values(by=['spread','test_score'],ascending=[True,False])        
-    #优先查看测试分数最高的结果
-    r2=r0.sort_values(by=['test_score','spread'],ascending=[False,True])
+    r1=r0[r0['spread'] <= diff]  #限定泛化差距
+    r1_len=len(r1)
+    #if r1_len==0 or r1_len>=votes:
+    if r1_len==0:
+        diff_new=r0['spread'].min()
+        r1=r0[r0['spread'] <= diff_new]
+        print("  #Warning: filtering parameter diff has been adjusted to",diff_new)
+    
+    
+    """
+    # 首选测试效果好的
+    r0=results[(results['test_score']>=min_score)]
+    if len(r0)==0:
+        test_quantile=results['test_score'].quantile(q=0.99,interpolation='nearest')
+        r0=results[(results['test_score']>test_quantile)]
+        if len(r0)==0:
+            r0=results[(results['test_score']>=test_quantile)]
+    
+        print("  #Warning: filtering parameter min_score for testing has been adjusted to",test_quantile)
+    """
 
-    if votes > len(r2): votes=len(r2)
-    r2head=r2.head(votes)
+    """
+    # 首选训练效果好的
+    r0=results[(results['train_score']>=min_score) & (results['train_score']<1.0)]
+    if len(r0)==0:
+        r0_train=results[(results['train_score']>=results['test_score']) & results['train_score']<1.0]
+        train_quantile=r0_train['train_score'].quantile(q=0.99,interpolation='nearest')
+        r0=r0_train[(r0_train['train_score']>train_quantile)]
+        if len(r0)==0:
+            r0=r0_train[(r0_train['train_score']>=train_quantile)]
     
-    zhang=len(r2head[r2head['pred']==1])
-    die=len(r2head[r2head['pred']==-1])
+        print("  #Warning: filtering parameter min_score for training has been adjusted to",train_quantile)
     
-    decision='+'
-    if zhang >= die * 2.0: decision='2+'
-    if zhang >= die * 3.0: decision='3+'
+    # 再选泛化效果好的
+    r1=r0[(r0['spread']<=diff)]
+    if len(r1)==0:
+        spread_quantile=r0['spread'].quantile(q=0.05,interpolation='nearest')
+        r1=r0[(r0['spread']<spread_quantile)]
+        if len(r1)==0:
+            r1=r0[(r0['spread']<=spread_quantile)]
+    
+        print("  #Warning: filtering parameter diff has been adjusted to",spread_quantile)
+    """
+    
+    #优先查看泛化效果最优的结果：spread最小
+    votes=min(votes,len(r1))
+    r2=r1.sort_values(by=['spread','test_score'],ascending=[True,False]).head(votes)        
+    #优先查看测试分数最高的结果：test_score最大
+    r3=r2.sort_values(by=['test_score','spread'],ascending=[False,True])
+
+    r3head=r3
     
-    if die > zhang: decision='-'
-    if die >= zhang * 2.0: decision='2-'
-    if die >= zhang * 3.0: decision='3-'
+    zhang=len(r3head[r3head['pred']==1])
+    die=len(r3head[r3head['pred']==-1])
     
-    if abs(zhang-die)/((zhang+die)/2) < 0.05: decision='?'
+    decision='+'
+    decision_text='HIGHER'
+    if die != 0:
+        if zhang >= die * 2.0: decision='2+'
+        if zhang >= die * 3.0: decision='3+'
+    
+    if die > zhang: 
+        decision='-'
+        decision_text='LOWER'
+        if zhang != 0:
+            if die >= zhang * 2.0: decision='2-'
+            if die >= zhang * 3.0: decision='3-'
+    
+    #if abs(zhang-die)/((zhang+die)/2) < 0.05: decision='?'
+    if zhang==die: 
+        decision='='
+        decision_text='FLAT'
 
     if not printout: return decision,today_close,today
 
-    print("  Model poll for stock price after "+str(ndays)+" trading days: Higer("+str(zhang)+'), Lower('+str(die)+')')
-    print("Last close price: "+ticker+', '+str(today_close)+', '+str(today))
-    print("Prediction for stock price after "+str(ndays)+" trading day: "+decision)
-    return decision,today_close,today
+    print("  Model voting for stock price after "+str(ndays)+" trading days: Higher("+str(zhang)+'), Lower('+str(die)+')')
+    print("  "+codetranslate(ticker)+': previously closed '+str(known_close)+' @ '+str(known_day))
+    
+    ndate=date_adjust(known_day,adjust=ndays)
+    print("  Prediction to close at",decision_text,"price trend ("+decision+') @',ndate)
+    
+    return decision,known_close,known_day
 
-if __name__=='__main__':
-    df=price_direction_knn('600519',ndays=1,max_neighbours=5,max_RS=2)
     
 #==============================================================================
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.SS'
     ndays=1
-    market='sh'
-    diff=0.03
+    diff=0.01
+    min_score=0.9
     votes=100
     max_neighbours=3
-    max_RS=2
+    max_RS=20
+    preproctype='0-1'
+    
+    df=forecast_direction_knn(ticker,ndays=1)
+    df=forecast_direction_knn(ticker,ndays=3)
 
-def forecast_direction_knn(ticker,ndays=1,diff=0.03,min_score=0.6,votes=100,max_neighbours=10,max_RS=10,preproctype='0-1'):
+def forecast_direction_knn(ticker,ndays=1,diff=0.01,min_score=0.9,votes=100,max_neighbours=10,max_RS=20,preproctype='0-1',end='latest'):
 
     """
     功能：基于个股资金流动预测未来股票涨跌方向，涨或跌
     ticker：股票代码，无后缀
     ndays：预测几天后的股价涨跌方向，默认1天
-    market：sh-沪市，sz-深市
-    diff：泛化精度，越小越好，默认0.03
+    diff：泛化精度，越小越好
+    min_score：最小训练/学习分数
     votes：软表决票数，默认最大100
     max_neighbours：最大邻居个数，默认10个
     max_RS：最大随机数种子，默认最大为10
     """
     print("\nStart forecasting, it may take great time, please wait ...")
     
     #抓取个股资金净流入情况df和大盘指数情况dp
-    df0,X,ydf=get_money_flowin(ticker)
-    scaler_X=preproc(X,preproctype=preproctype)
-    
-    #测试用
-    df=df0.copy()
+    df=get_money_flowin(ticker,end=end)
     
     #预测未来股价涨跌
     decisionlist=[]
     for nd in list(range(1,ndays+1)):
-        decision,today_close,today=price_direction_knn(ticker,df,ndays=nd, \
-            diff=diff,min_score=min_score,votes=votes,max_neighbours=max_neighbours,max_RS=max_RS)
+        decision,known_close,known_day=price_direction_knn(ticker,df,ndays=nd, \
+                                                       diff=diff, \
+                                                       min_score=min_score, \
+                                                       votes=votes, \
+                                                       max_neighbours=max_neighbours, \
+                                                       max_RS=max_RS)
         decisionlist=decisionlist+[decision]
 
-    print("\nStock information:",ticker,today_close,today)
-    print("Forecasting stock prices in next",ndays,"trading days: ",end='')
-    for i in decisionlist:
-        print(i,'\b ',end='')
-    print('\b.')
-    
-    return
+    print("\nStock information:",codetranslate(ticker),'\b, closed',known_close,'@',known_day)
+    for nd in list(range(1,ndays+1)):
+        ndate=date_adjust(known_day, adjust=nd)
+        print("Forecasting stock close price trend on",ndate,end=': ')
+        pred=decisionlist[nd-1]
+        if '-' in pred:
+            print("LOWER,",pred)
+        if '+' in pred:
+            print("HIGHER,",pred)
+        if '~' in pred:
+            print("market closed")            
+        if '=' in pred:
+            print("least different")  
+            
+    return decisionlist,known_close,known_day
 
-if __name__=='__main__':
-    df=forecast_direction_knn('600519',ndays=1,max_neighbours=5,max_RS=2)
 
 #==============================================================================
 # Forecasting stock prices by money flow in/out, using knn
 #==============================================================================
 
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.SS'
+    ticker='605011.SS'
+    
     ndays=1
-    market='sh'
-    diff=0.03
+    diff=0.01
+    min_score=0.8
     votes=100
     max_neighbours=10
     max_RS=10
+    printout=True
+    
+    df=get_money_flowin(ticker,end='2023-6-15')
+    pred_result=price_price_knn(ticker,df,ndays=1)
+    pred_result=price_price_knn(ticker,df,ndays=3)
 
-def price_price_knn(ticker,df,ndays=1,diff=0.03,min_score=0.6,votes=100,max_neighbours=10,max_RS=10,printout=True):
-
+#def price_price_knn(ticker,df,ndays=1,diff=0.01,min_score=0.8,votes=100,max_neighbours=10,max_RS=20,printout=True):
+def price_price_knn(ticker,df,ndays=1,max_neighbours=10,max_RS=20,printout=True):
+    
     """
     功能：基于个股资金流动预测次日股票价格
     ticker：股票代码，无后缀
     df：个股资金净流入信息
-    dp：大盘信息
     ndays：预测几天后的股价涨跌方向，默认1天
-    market：sh-沪市，sz-深市
-    diff：泛化精度，越小越好，默认0.03
-    votes：软表决均值，默认100
+    diff：弃用。泛化精度，越小越好
+    min_score：弃用。最小训练/测试分数，越大越好
+    votes：弃用。软表决均值，默认100
     max_neighbours：最大邻居个数
     max_RS：最大随机数种子
     """
     import pandas as pd
+ 
+    # 判断是否周末无交易免预测
+    known_day=df.tail(1)['date'].values[0]
+    
+    tdate=date_adjust(known_day, adjust=ndays)
+    tdate_pd=pd.to_datetime(tdate)
+    tdate_wd=tdate_pd.weekday()
+    if tdate_wd in [5,6]:
+        print("  #Warning: after",ndays,"day(s) is",tdate,"(weekend), no trading")
+        decision=0
+        decision_score=0
+        known_close=df.tail(1)['Close'].values[0]
+        
+        return decision,decision_score,known_close,known_day   
+ 
+    #构造样本：标签ydf，特征矩阵X，预测X_new
+    X,ydf,X_new=make_sample(df,ndays=ndays)
     
-    #构造标签
-    df['nextClose']=df['Close'].shift(-ndays)
-    df['nextChange%']=df['Change%'].shift(-ndays)
-    df['nextDirection']=df['nextChange%'].apply(lambda x: 1 if float(x) > 0 else -1)
-    
-    #构造特征
-    df['netFlowInChg_main']=df['netFlowInAmount_main']/(df['netFlowInAmount_main'].shift(ndays))
-    df['netFlowInChg_small']=df['netFlowInAmount_small']/(df['netFlowInAmount_small'].shift(ndays))
-    df['netFlowInChg_mid']=df['netFlowInAmount_mid']/(df['netFlowInAmount_mid'].shift(ndays))
-    df['netFlowInChg_big']=df['netFlowInAmount_big']/(df['netFlowInAmount_big'].shift(ndays))
-    df['netFlowInChg_super']=df['netFlowInAmount_super']/(df['netFlowInAmount_super'].shift(ndays))
-    df['netFlowInChg']=df['netFlowInAmount']/(df['netFlowInAmount'].shift(ndays))
-
-    df['dpCloseChg']=df['dpClose']/(df['dpClose'].shift(ndays))
-    df['dpVolumeChg']=df['dpVolume']/(df['dpVolume'].shift(ndays))
-
-    df2=df[['date','netFlowInChg_main',
-       'netFlowInChg_small','netFlowInChg_mid','netFlowInChg_big', \
-       'netFlowInChg_super','netFlowInChg','netFlowInRatio%_main','netFlowInRatio%_small', \
-       'netFlowInRatio%_mid','netFlowInRatio%_big','netFlowInRatio%_super', \
-       'Close','Change%','dpCloseChg','dpVolumeChg','nextClose','nextChange%','nextDirection']]
-
-    #记录最新指标，用于预测次日涨跌
-    x_last=df2.copy().tail(1)
-    today=x_last['date'].values[0]
-    today_close=x_last['Close'].values[0]
-    x_last.drop(labels=['date','nextClose', 'nextChange%', 'nextDirection'],axis=1,inplace=True)
-    X_new = x_last.head(1).values
-
-    #建立样本：特征序列
-    df2.dropna(inplace=True)
-    X=df2.drop(labels=['date','nextClose', 'nextChange%', 'nextDirection'],axis=1)
+    known_day_np=X_new.index.values[0]
+    known_day_pd=pd.to_datetime(known_day_np)    
+    known_day=known_day_pd.strftime("%Y-%m-%d")
+    known_close=X_new['Close'].values[0]    
 
     #建立样本：标签序列
     #y1=df2['nextDirection'] #二分类
     #y2=df2['nextChange%']   #回归
-    y3=df2['nextClose']     #回归
+    y3=ydf['Close_next']      #回归
 
     #拆分训练集和测试集：y1
     from sklearn.model_selection import train_test_split
     #引入k近邻分类模型：
     from sklearn.neighbors import KNeighborsRegressor
 
     #寻找最优模型参数
@@ -668,140 +809,224 @@
     wlist=['uniform','distance']
     mlist1=['braycurtis','canberra','correlation','dice','hamming','jaccard']
     mlist2=['kulsinski','matching','rogerstanimoto','russellrao']
     mlist3=['sokalmichener','sokalsneath','sqeuclidean','chebyshev']
     mlist4=['cityblock','euclidean','minkowski','cosine']
     mlist=mlist1+mlist2+mlist3+mlist4
     rslist=list(range(0,max_RS+1))
+    
     results=pd.DataFrame(columns=('spread','train_score','test_score', \
                                   'neighbours','weight','metric','random','pred'))
     print('\nSearching for best parameters of knn model in',ndays,'trading days ...')
-    print('  Progress: 0%, ',end='')
+    print('  Progress: 0% ',end='')
     for n in nlist:
         for w in wlist:
             for m in mlist:
                 for rs in rslist: 
                     try:
                         knn1=KNeighborsRegressor(n_neighbors=n,weights=w,metric=m,n_jobs=-1)
                         X_train,X_test,y_train,y_test=train_test_split(X,y3,random_state=rs)
-                        knn1.fit(X_train, y_train)
+                        tmp=knn1.fit(X_train, y_train)
                         train_score=round(knn1.score(X_train, y_train),3)
                         test_score=round(knn1.score(X_test, y_test),3)
                         prediction=knn1.predict(X_new)[0]
                     except:
-                        print("  #Bug: n=",n,"w=",w,"m=",m,"rs=",rs)
-                        break
+                        #print("  #Bug parameters: n=",n,"w=",w,"m=",m,"rs=",rs)
+                        #break
+                        continue
                     spread=abs(round(train_score-test_score,3))
                     
                     row=pd.Series({'spread':spread,'train_score':train_score, \
                                    'test_score':test_score,'neighbours':n, \
                                    'weight':w,'metric':m,'random':rs,'pred':prediction})
                     results=results.append(row,ignore_index=True)
-        print(int(n/n_num*100),'\b%, ',end='')
-    print('done.') 
+        print(int(n/n_num*100),'\b% ',end='')
+    print('.') 
+    
+    # 过滤训练/测试分数差的结果
+    """
+    r0=results[(results['train_score']>=min_score) & (results['test_score']>=min_score)]
+    
+    # 如果最低分数设置太高
+    r0_len=len(r0)
+    if r0_len==0:
+        train_score_max=results['train_score'].max()
+        test_score_max=results['test_score'].max()
+        min_score_new=min(train_score_max,test_score_max)
+        r0=results[(results['train_score']>=min_score_new) & (results['test_score']>=min_score_new)]
+        
+        if len(r0)==0:
+            spread_quantile=results['spread'].quantile(q=0.01)
+            r0_spread=results[(results['spread']<spread_quantile)]
+            if len(r0_spread)==0:
+                r0_spread=results[(results['spread']<=spread_quantile)]
+
+            test_score_quantile=r0_spread['test_score'].quantile(q=0.99)
+            r0=r0_spread[(r0_spread['test_score']>test_score_quantile)]
+            if len(r0)==0:
+                r0=r0_spread[(r0_spread['test_score']>=test_score_quantile)]
+                
+            train_score_max=r0['train_score'].max()
+            test_score_max=r0['test_score'].max()
+            min_score_new=min(train_score_max,test_score_max)
+            
+        print("  #Warning: filtering parameter min_score has been adjusted to",min_score_new)        
+    """
+    
+    train_score_max=results['train_score'].max()
+    test_score_max=results['test_score'].max()
+    min_score_new=min(train_score_max,test_score_max)
+    r0=results[(results['train_score']>=min_score_new) & (results['test_score']>=min_score_new)]
+    
+    if len(r0)==0:
+        spread_quantile=results['spread'].quantile(q=0.01)
+        r0_spread=results[(results['spread']<spread_quantile)]
+        if len(r0_spread)==0:
+            r0_spread=results[(results['spread']<=spread_quantile)]
+
+        test_score_quantile=r0_spread['test_score'].quantile(q=0.99)
+        r0=r0_spread[(r0_spread['test_score']>test_score_quantile)]
+        if len(r0)==0:
+            r0=r0_spread[(r0_spread['test_score']>=test_score_quantile)]
+            
+        train_score_max=r0['train_score'].max()
+        test_score_max=r0['test_score'].max()
+        min_score_new=min(train_score_max,test_score_max)
     
-    #去掉严重过拟合的结果           
-    r0=results[results['train_score'] < 1]
-    #去掉训练集、测试集分数不过半的模型    
-    r0=r0[r0['train_score'] > min_score]
-    r0=r0[r0['test_score'] > min_score]
     #去掉泛化效果差的结果
-    r0=r0[r0['spread'] < diff]  #限定泛化差距
-    #优先查看泛化效果最优的结果
-    r1=r0.sort_values(by=['spread','test_score'],ascending=[True,False])        
-    #优先查看测试分数最高的结果
-    r2=r0.sort_values(by=['test_score','spread'],ascending=[False,True])
-
-    if votes > len(r2): votes=len(r2)
-    r2head=r2.head(votes)
+    """
+    r1=r0[r0['spread'] <= diff]  #限定泛化差距
+    r1_len=len(r1)
     
+    if r1_len==0:
+        diff_new=r0['spread'].min()
+        r1=r0[r0['spread'] <= diff_new]
+        print("  #Warning: filtering parameter diff has been adjusted to",diff_new)
+    """
     
-    #加权平均股价
-    r2head['w_pred']=r2head['pred'] * r2head['test_score']
-    w_pred_sum=r2head['w_pred'].sum()
-    test_score_sum=r2head['test_score'].sum()
-    decision=round(w_pred_sum / test_score_sum,2)
-    decision_score=round(r2head['test_score'].mean(),2)
+    diff_new=r0['spread'].min()
+    r1=r0[r0['spread'] == diff_new]
     
+    #优先查看泛化效果最优的结果：spread最小
+    """
+    votes=min(votes,len(r1))
+    r2=r1.sort_values(by=['spread','test_score'],ascending=[True,False]).head(votes)        
+    #优先查看测试分数最高的结果：test_score最大
+    r3=r2.sort_values(by=['test_score','spread'],ascending=[False,True])
+    """
+    
+    r3head=r1
+    #平均股价
+    decision=round(r3head['pred'].mean(),2)
+    decision_score=round(r3head['test_score'].mean(),3)
+    
+    """
+    r3head['w_pred']=r3head['pred'] * r3head['test_score']
+    w_pred_sum=r3head['w_pred'].sum()
+    test_score_sum=r3head['test_score'].sum()
+    decision=round(w_pred_sum / test_score_sum,2)
+    decision_score=round(r3head['test_score'].mean(),2)
+    """
     """
     #股价中位数：偶尔出现奇怪的错误，未找到原因
-    decision0=r2head['pred'].median()
-    pos=list(r2head['pred']).index(decision0)
-    decision_score0=list(r2head['test_score'])[pos]
+    decision0=r3head['pred'].median()
+    pos=list(r3head['pred']).index(decision0)
+    decision_score0=list(r3head['test_score'])[pos]
     decision=round(decision0,2)
     decision_score=round(decision_score0,2)
     """
     import numpy as np
-    if decision == np.nan: decision='?'
+    if np.isnan(decision): decision='?'
     
     if not printout: return decision,decision_score,today_close,today
 
     print("  Model poll for stock price after "+str(ndays)+" trading days:",decision)
-    print("Last close price: "+ticker+', '+str(today_close)+', '+str(today))
-    print("Prediction for stock price after "+str(ndays)+" trading day:",decision)
-    return decision,decision_score,today_close,today
+    print("  Last close price: "+codetranslate(ticker)+', closed '+str(known_close)+', '+str(known_day))
+    
+    ndate=date_adjust(known_day,adjust=ndays)
+        
+    print("  Prediction for stock close price on",ndate,"\b:",decision)
+    
+    return decision,decision_score,known_close,known_day
 
-if __name__=='__main__':
-    df=get_money_flowin(ticker)
-    df=price_price_knn('600519',df,ndays=1,max_neighbours=3,max_RS=2)
     
 #==============================================================================
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.SS'
     ndays=1
-    market='sh'
-    diff=0.03
-    votes=100
     max_neighbours=3
     max_RS=2
+    
+    forecast=forecast_price_knn(ticker,ndays=1,end='2023-6-15')
+    forecast=forecast_price_knn(ticker,ndays=3,end='2023-6-15')
 
-def forecast_price_knn(ticker,ndays=1,diff=0.03,min_score=0.6,votes=100,max_neighbours=10,max_RS=10):
-
+#def forecast_price_knn(ticker,ndays=1,diff=0.03,min_score=0.7,votes=100,max_neighbours=10,max_RS=10,end='latest'):
+def forecast_price_knn(ticker,ndays=1,max_neighbours=10,max_RS=20,end='latest'):
     """
     功能：基于个股资金流动预测未来股票价格
     ticker：股票代码，无后缀
     ndays：预测几天后的股价，默认1天
-    market：sh-沪市，sz-深市
-    diff：泛化精度，越小越好，默认0.03
-    votes：软表决均值，默认最大100
+    diff：弃用。泛化精度，越小越好
+    min_score：弃用。最小训练/测试分数，越大越好
+    votes：弃用。软表决均值，默认最大100
     max_neighbours：最大邻居个数，默认10个
-    max_RS：最大随机数种子，默认最大为10
+    max_RS：最大随机数种子，越大越好
+    
+    注意：结果经常相当不靠谱！
     """
     print("\nStart forecasting, it may take great time, please wait ...")
     
     #抓取个股资金净流入情况df和大盘指数情况dp
-    df0=get_money_flowin(ticker)
-    
-    #测试用
-    df=df0.copy()
+    df=get_money_flowin(ticker,end=end)
     
     #预测未来股价涨跌
     decisionlist=[]
     confidencelist=[]
     for nd in list(range(1,ndays+1)):
-        decision,confidence,today_close,today=price_price_knn(ticker,df,ndays=nd, \
-            diff=diff,min_score=min_score,votes=votes,max_neighbours=max_neighbours,max_RS=max_RS)
+        """
+        decision,confidence,known_close,known_day=price_price_knn(ticker,df,ndays=nd, \
+                                                              diff=diff, \
+                                                              min_score=min_score, \
+                                                              votes=votes, \
+                                                              max_neighbours=max_neighbours, \
+                                                              max_RS=max_RS)
+        """
+        decision,confidence,known_close,known_day=price_price_knn(ticker,df,ndays=nd, \
+                                                              max_neighbours=max_neighbours, \
+                                                              max_RS=max_RS)
+        
         decisionlist=decisionlist+[decision]
         confidencelist=confidencelist+[confidence]
 
-    print("\nStock information:",ticker,today_close,today)
-    print("Forecasting stock prices in next",ndays,"trading days: ",end='')
-    for i in decisionlist:
-        pos=decisionlist.index(i)
-        conf=confidencelist[pos]
-        if i == '?':
-            print('?',end='')
+    print("\nStock information:",codetranslate(ticker),'\b, closed',known_close,'@',known_day)
+
+    for nd in list(range(1,ndays+1)):
+        ndate=date_adjust(known_day, adjust=nd)
+        pred=decisionlist[nd-1]  
+        conf=confidencelist[nd-1]
+        
+        if (pred != 0) & (conf != 0):
+            if pred != '?':
+                diff=decision - known_close
+                if abs(diff) < 0.05:
+                    comment="MINOR difference with previous one"
+                elif diff > 0:
+                    comment="HIGHER than previous one"
+                else:
+                    comment="LOWER than previous one"
+                
+                print("Forecasting stock prices on",ndate,'\b:',pred,'('+str(round(conf*100,1))+'% confident)')
+                print("Forecasting stock prices trend on",ndate,'\b:',comment)
+            else:
+                print("Forecasting stock prices on",ndate,'\b: uncertain')
         else:
-            print(str(i)+'('+str(conf*100)+'%) ',end='')
-    print('\b.')
+            print("Forecasting stock prices on",ndate,'\b: market closed')
     
-    return
+    return decisionlist,confidencelist
 
-if __name__=='__main__':
-    df=forecast_price_knn('600519',ndays=1,max_neighbours=5,max_RS=2)
 
 #==============================================================================
 #==============================================================================
 #==============================================================================
 if __name__=='__main__':
     mid_symbol=['；','。']
     mid_symbol=['。','；']
```

## siat/stock_china_test.py

```diff
@@ -7,32 +7,32 @@
 import akshare as ak
 l1=ticker[0]; market='sh'
 if l1 in ['0','2','3']: market='sz'
 df = ak.stock_individual_fund_flow(stock=ticker, market=market)
 df.to_excel("D:/BFSU WORK/600519MFI.xlsx",index=False,encoding='utf-8',sheet_name='Sheet1')
 
 if __name__=='__main__':
-    ticker='600519'
+    ticker='600519.SS'
     dfp=get_money_flowin(ticker)
 
     X,ydf=make_sample(dfp,ndays=1,preCumTimes=1)
     
-    scaler_X1=preproc(X,preproctype='min-max')
-    scaler_X2=preproc(X,preproctype='0-1')
-    scaler_X3=preproc(X,preproctype='log')
+    scaler_X1=preprocess(X,preproctype='min-max')
+    scaler_X2=preprocess(X,preproctype='0-1')
+    scaler_X3=preprocess(X,preproctype='log')
 
 
 #==============================================================================
-ticker='600519'
+ticker='600519.ss'
 
 forecast_direction_knn(ticker,ndays=5,max_neighbours=2,max_RS=2)
 
 if __name__=='__main__':
     df=get_money_flowin(ticker)
-    df=price_price_knn('600519',df,ndays=1,max_neighbours=3,max_RS=2)
+    df=price_price_knn('600519.SS',df,ndays=1,max_neighbours=3,max_RS=2)
 
 forecast_price_knn(ticker,ndays=1,max_neighbours=2,max_RS=2)
 
 
 forecast_direction_knn(ticker,ndays=5,max_neighbours=10,max_RS=10)
 forecast_price_knn(ticker,ndays=5,max_neighbours=10,max_RS=10)
 #==============================================================================
```

## siat/translate.py

```diff
@@ -777,15 +777,15 @@
         ['AAPL','苹果'],['Apple','苹果'],['DELL','戴尔'],['IBM','国际商用机器'],
         ['MSFT','微软'],['Microsoft','微软'],['HPQ','惠普'],['AMD','超威半导体'],
         ['NVDA','英伟达'],['INTC','英特尔'],['QCOM','高通'],['BB','黑莓'],
         
         #股票：电商、互联网        
         ['AMZN','亚马逊'],['Amazon','亚马逊'],
         ['SHOP','Shopify'],['MELI','美客多'],
-        ['EBAY','易贝'],['eBay','易贝'],['FB','脸书'],['ZM','ZOOM'],
+        ['EBAY','易贝'],['eBay','易贝'],['META','脸书'],['ZM','ZOOM'],
         ['GOOG','谷歌'],['TWTR','推特'],
         ['VIPS','唯品会'],['Vipshop','唯品会'],
         ['PDD','拼多多'],['Pinduoduo','拼多多'],        
         ['BABA','阿里巴巴美股'],['Alibaba','阿里巴巴美股'],
         ['JD','京东美股'],
         ['SINA','新浪网'],['BIDU','百度'],['NTES','网易'],
         
@@ -1280,15 +1280,15 @@
         ['AAPL','Apple'],['Apple','Apple'],['DELL','DELL'],['IBM','IBM'],
         ['MSFT','Microsoft'],['Microsoft','Microsoft'],['HPQ','HP'],['AMD','AMD'],
         ['NVDA','NVidia'],['INTC','Intel'],['QCOM','Qualcomm'],['BB','Blackberry'],
         
         #股票：电商、互联网        
         ['AMZN','Amazon'],['Amazon','Amazon'],
         ['SHOP','Shopify'],['MELI','Mercado Libre'],
-        ['EBAY','eBay'],['eBay','eBay'],['FB','Facebook'],['ZM','ZOOM'],
+        ['EBAY','eBay'],['eBay','eBay'],['META','META'],['ZM','ZOOM'],
         ['GOOG','Google'],['TWTR','Twitter'],
         ['VIPS','Vipshop'],['Vipshop','Vipshop'],
         ['PDD','Pinduoduo'],['Pinduoduo','Pinduoduo'],        
         ['BABA','Alibaba(US)'],['Alibaba','Alibaba'],
         ['JD','JD(US)'],
         ['SINA','Sina'],['BIDU','Baidu'],['NTES','Netease'],
```

## Comparing `siat-2.1.1.dist-info/METADATA` & `siat-2.1.5.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: siat
-Version: 2.1.1
+Version: 2.1.5
 Summary: Securities Investment Analysis Tools (siat)
 Home-page: https://pypi.org/project/siat/
 Author: Prof. WANG Dehong, Business School, BFSU (北京外国语大学 国际商学院 王德宏 教授)
 Author-email: wdehong2000@163.com
 License: Copyright (C) WANG Dehong, 2023. For educational purpose only!
 Platform: UNKNOWN
 Requires-Dist: pandas-datareader
```

## Comparing `siat-2.1.1.dist-info/RECORD` & `siat-2.1.5.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -50,15 +50,15 @@
 siat/fund_china.pickle,sha256=hsPjNAQtvCMTPQV5lFk3sS7cngetWaxFvdyEtNvnU14,2047492
 siat/fund_china.py,sha256=UOYUGxYdRV0i4VNqzROHxD65K6dyd-U4zKagkUTTAuk,74734
 siat/fund_china_test.py,sha256=-Bh6m0J0GPpIbYXx-H2vpzJoNFI6pE2C2jVPa8DazgE,6649
 siat/fund_test.py,sha256=V4ADb8Gsp8gyeFTwcgRsJBpnUih_O-Q2V1ILc5oKjK8,1116
 siat/future_china.py,sha256=PCHpxxC-eBDo3P_nkSeQzMnVCt-H7YAZEDJcxfkdnuU,17513
 siat/future_china_test.py,sha256=BrSzmDVaOHki6rntOtosmRn-6dkfOBuLulJNqh7MOpc,1163
 siat/global_index_test.py,sha256=hnFp3wqqzzL-kAP8mgxDZ54Bd5Ijf6ENi5YJlGBgcXw,2402
-siat/grafix.py,sha256=fQhoWKUjmaLBpD8smNf0Sn53wxrHCzIqeP20P5qWOCc,63837
+siat/grafix.py,sha256=SslCHur0_9TIIV75kLabaFX8V4LARoH-CldwA0ZDcwo,64367
 siat/grafix_test.py,sha256=kXvcpLgQNO7wd30g_bWljLj5UH7bIVI0_dUtXbfiKR0,3150
 siat/holding_risk.py,sha256=108tiI7DDl8uUZkyUiq6Y-McKeim1mxYsgqgk7CcXw8,30544
 siat/holding_risk_test.py,sha256=FRlw_9wFG98BYcg_cSj95HX5WZ1TvkGaOUdXD7-V86s,474
 siat/local_debug_test.py,sha256=CDAOffW1Rvs-TcNN5giWVvHMlch1w4dp-w5SIV9jXL0,3936
 siat/market_china.py,sha256=2_ov1KQwRtHQ6PXNO1TS4-wUPhBuoWla326g0x_xUgQ,31158
 siat/markowitz.py,sha256=g3P-UripHV_VwtQetdGaPtfmRsFUxQICqmtF4Pp6C3k,95641
 siat/markowitz_ccb_test.py,sha256=xBkkoaNHdq9KSUrNuHGgKTdNYUvgi84kNYcf719eoyE,1593
@@ -84,19 +84,19 @@
 siat/sector_china.py,sha256=sHd7nlYWCK0SWAZbu-BLn-3vNPe2E8OFaDFYF67Hoho,101523
 siat/sector_china_test.py,sha256=1wq7ef8Bb_L8F0h0W6FvyBrIcBTEbrTV7hljtpj49U4,5843
 siat/security_price.py,sha256=2oHskgiw41KMGfqtnA0i2YjNNV6cYgtlUK0j3YeuXWs,29185
 siat/security_prices.py,sha256=xDK2HSsiyedQIvjcU56yZZCa9mnTNQfJfVWnx9ihPVs,72184
 siat/security_prices_test.py,sha256=OEphoJ87NPKoNow1QA8EU_5MUYrJF-qKoWKNapVfZNI,10779
 siat/setup.py,sha256=up65rQGLmTBkhtaMLowjoQXYmIsnycnm4g1SYmeQS6o,1335
 siat/shenwan index history test.py,sha256=JCVAzOSEldHalhSFa3pqD8JI_8_djPMQOxpkuYU-Esg,1418
-siat/stock.py,sha256=kRwm-hZ5oLj7HAaZo5lhNVNoGri3Zi10fUH-hvK8ZM4,118751
+siat/stock.py,sha256=swB1HjQhImaQ6zEsSHgiLODXFHUPYCbkU5Y6dCIaEvc,118820
 siat/stock_advice_linear.py,sha256=-twT7IGP-NEplkL1WPSACcNJjggRB2j4mlAQCkzOAuo,31655
 siat/stock_base.py,sha256=uISvbRyOGy8p9QREA96CVydgflBkn5L3OXOGKl8oanc,1312
-siat/stock_china.py,sha256=Hj1El4SxcSc1hrsOcPhya-sLh1Ppmesg9DKkZ-B85Rk,76007
-siat/stock_china_test.py,sha256=Qc1m19FAUSvBi9E0ZTVcYBveiGYFIlIFvthbidzCe1s,1276
+siat/stock_china.py,sha256=jVSuCWr6TaTx0Y0sgqN-dU9ZL72uKiI_MzvugvH9NaI,82785
+siat/stock_china_test.py,sha256=eO4HWsSvc6qezl0LndjtL24lViEyrBjH_sx2c2Y2Q2M,1294
 siat/stock_info.pickle,sha256=o4M-pcN8Sh8QiwZQAZWY1aelI4xgIGIxors7n2uHSJI,1266744
 siat/stock_info_test.py,sha256=gfG3DbhDACbtD8wnv_R6zhj0t11XaC8NX8uLD9Qv3Fo,6122
 siat/stock_list_china_test.py,sha256=gv14UwMMvkZqtb6G7DCTSuehIwVHuVwu7w60p6gyHoo,1014
 siat/stock_prices_kneighbors.py,sha256=WfZvo5EyeBsm-T37zDj7Sl9dPSRq5Bx4JxIJ9IUum6s,36738
 siat/stock_prices_linear.py,sha256=-OUKRr27L2aStQgJSlJOrJ4gay_G7P-m-7t7cU2Yoqk,13991
 siat/stock_profile.py,sha256=kEoYOsHm0Kc75gEVchDbPbJNfzPvNi6QKTxMySo_2Fg,25017
 siat/stock_technical.py,sha256=MiW5LwWGBq8BqxjS8PD0wMSHPiwlIVixeeNJfq395J8,72626
@@ -105,16 +105,16 @@
 siat/test2_graphviz.py,sha256=05w2YJuIBH0LsJjdA60EFn7rL0vCo-CA6EVJEQOXNE4,16648
 siat/test_graphviz.py,sha256=CETKpDL8PnysS-PD3fHkeAgagUxjaUl0CsXPiadQySg,16999
 siat/transaction.py,sha256=foTWS1qYXQFuzNTG2m7ec6aDgsJjzpKmyAbyxKcE8KU,14492
 siat/transaction_test.py,sha256=Z8g1LJCN4-mnUByXMUMoFmN0t105cbmsz2QmvSuIkbU,18580
 siat/translate-20230125.py,sha256=NPPSXhT38s5t9fzMvl_fvi4ckSB73ThLmZetVI-xGdU,117953
 siat/translate-20230206.py,sha256=-vtI125WyaJhmPotOpDAmclt_XnYVaWU9ByLWZ6FyYE,118133
 siat/translate-20230215.py,sha256=TJgtPE3n8IjljmZ4Pefy8dmHoNdFF-1zpML6BhA9FKE,121657
-siat/translate.py,sha256=BqVhWPWwVBCc8xS83LdL5EtlM8zbDbfKKPl8FfrlNuM,133928
+siat/translate.py,sha256=nS9gqygAkb-2M2utEjucdw-5kWe7hCrDW1OqX3sed7E,133928
 siat/universal_test.py,sha256=CDAOffW1Rvs-TcNN5giWVvHMlch1w4dp-w5SIV9jXL0,3936
 siat/valuation_china.py,sha256=gYYXeT9bBPyQ251TCsYlibWcu6JA8x-YOKqLUEeLE7U,51342
 siat/valuation_market_china_test.py,sha256=gbJ0ioauuo4koTPH6WKUkqcXiQPafnbhU5eKJ6lpdLA,1571
 siat/var_model_validation.py,sha256=zB_Skk_tmzIR15l6oAW3am4HBGVIG-eZ8gJhCdXZ8Qw,14859
-siat-2.1.1.dist-info/METADATA,sha256=l8Zn5wi8JkR5pCcjsJxe3-TNiOTJuELSxhvSGhjLFY8,1410
-siat-2.1.1.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
-siat-2.1.1.dist-info/top_level.txt,sha256=r1cVyL7AIKqeAmEJjNR8FMT20OmEzufDstC2gv3NvEY,5
-siat-2.1.1.dist-info/RECORD,,
+siat-2.1.5.dist-info/METADATA,sha256=l813XBKUMdV7LKxkkj9w92tLkcHooA-SNvcFocfZ2ts,1410
+siat-2.1.5.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
+siat-2.1.5.dist-info/top_level.txt,sha256=r1cVyL7AIKqeAmEJjNR8FMT20OmEzufDstC2gv3NvEY,5
+siat-2.1.5.dist-info/RECORD,,
```

